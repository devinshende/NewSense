<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Content Editor</title>
    <!-- Load Tailwind CSS for styling and responsiveness -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load GSAP Core Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
            overflow-x: hidden;
            /* Prevent horizontal scroll from character movement */
        }

        .mode-select {
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20'%3E%3Cpath fill='%236B7280' d='M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 0.75rem center;
            background-size: 1.5em;
        }

        /* Style for the document container */
        .document-card {
            background-color: #ffffff;
            border-radius: 1rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            max-width: 4xl;
            width: 90%;
            /* Relative position needed for absolute children (character layer) */
            position: relative;
        }

        /* Layer for the animated characters, positioned over the content */
        #character-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            /* Allows clicks to pass through to the document below */
            z-index: 10;
        }



        .character {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            position: absolute;
            opacity: 0.9;
            pointer-events: none;
            box-shadow: 0 6px 14px rgba(16, 24, 40, 0.12);
        }

        /* Words are inline-block so we can transform/blur individual words without collapsing layout */
        .word {
            display: inline-block;
            white-space: pre;
            /* preserve spaces/newlines between words */
            will-change: transform, filter;
        }

        /* Redacted text styling - black highlight effect */
        .redacted {
            background-color: #000000 !important;
            color: transparent !important;
            text-shadow: none !important;
            user-select: none;
            border-radius: 3px;
            position: relative;
            padding: 2px 4px;
            margin: 0 1px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        /* Ensure redacted text can't be selected or revealed */
        .redacted::selection {
            background-color: #000000;
            color: transparent;
        }

        @keyframes redact-in {
            from {
                background-color: transparent;
                transform: scaleX(0);
            }
            to {
                background-color: #000000;
                transform: scaleX(1);
            }
        }

        /* Kristina sprite sizing */
        #char-5 {
            width: 100px;
            height: 140px;
        }

        /* Make the UCSC jeff sprite twice the base character size */
        #char-3 {
            width: 96px;
            height: 96px;
        }

        /* baby girl Jeff */
        #char-6 {
            width: 140px;
            height: 140px;
        }

        /* Make the Cal sprite larger */
        #char-7 {
            width: 146px;
            height: 146px;
        }

        /* Carmen sprite sizing */
        #char-4 {
            width: 100px;
            height: 160px;
        }

        /* Sabina sprite sizing */
        #char-2 {
            width: 50px;
            height: 150px;
        }

        /* Full-area red overlay for special collision effect (initially transparent) */
        #screen-overlay {
            position: absolute;
            inset: 0;
            background-color: rgba(255, 0, 0, 0);
            pointer-events: none;
            z-index: 40;
            border-radius: 1rem;
        }
    </style>
</head>

<body class="flex flex-col items-center min-h-screen p-6 md:p-10">

    <!-- Document Container -->
    <div id="document-card" class="document-card p-8 md:p-16 w-full">

        <a href="index.html" class="inline-flex items-center text-blue-600 hover:text-blue-800 mb-6 font-medium">
            <!-- Back Arrow SVG Icon -->
            <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"
                xmlns="http://www.w3.org/2000/svg">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18">
                </path>
            </svg>
            Back to Input
        </a>

        <!-- Title Section -->
        <h1 id="notebook-title"
            class="text-4xl md:text-5xl font-black mb-4 text-gray-800 border-b-2 pb-4 border-gray-200">
            Focus Mode
        </h1>

        <!-- Mode Selector Dropdown -->
        <div class="mb-10 flex flex-col sm:flex-row sm:items-center space-y-3 sm:space-y-0 sm:space-x-4">
            <label for="style-mode" class="text-lg font-semibold text-gray-700">Select Mode:</label>
            <select id="style-mode"
                class="mode-select block w-full sm:w-64 p-3 border border-gray-300 rounded-lg bg-gray-50 focus:ring-blue-500 focus:border-blue-500 text-base mode-select cursor-pointer">
                <option value="corporate">üíº LinkedIn / Corporate Speak</option>
                <option value="emoji">üòÇ Horrible Emojis Copypasta</option>
                <option value="argumentative">‚öîÔ∏è Argumentative Mode</option>
                <option value="forgetful">ü§î Forgetful Mode</option>
                <option value="brainrot">ü§™ Brainrot / Slang</option>
            </select>
        </div>


        <!-- Output Area for Generated Text -->
        <div id="output-area" class="space-y-6 text-lg text-gray-700 leading-relaxed min-h-[400px]">
            <!-- Content will be injected here by JavaScript -->
            <p>Paste text on the home page to begin transformation.</p>
        </div>

        <!-- Character Animation Layer -->
        <div id="character-layer">
            <div id="char-1" class="character" style="background-color: #a21f1f;"></div>
            <!-- char-2 uses Sabina.png sprite -->
            <div id="char-2" class="character"
                style="background-image: url('assets/Sabina.png'); background-size: cover; background-position: center; background-repeat: no-repeat;">
            </div>
            <!-- char-3 uses an image sprite from assets/ucscjeff.png -->
            <div id="char-3" class="character"
                style="background-image: url('assets/ucscjeff.png'); background-size: cover; background-position: center; background-repeat: no-repeat;">
            </div>
            <!-- char-4 uses Carmen.png sprite -->
            <div id="char-4" class="character"
                style="background-image: url('assets/Carmen.png'); background-size: cover; background-position: center; background-repeat: no-repeat;">
            </div>
            <!-- char-5 uses an image sprite from assets/Kristina.png -->
            <div id="char-5" class="character"
                style="background-image: url('assets/Kristina.png'); background-size: cover; background-position: center; background-repeat: no-repeat;">
            </div>
            <div id="char-6" class="character" style="background-color: #b393d9;"></div>
            <!-- char-6 uses jeffbaby placeholder SVG (replace with PNG if you add it into assets/) -->
            <div id="char-6" class="character"
                style="background-image: url('assets/jeffbaby.JPG'); background-size: cover; background-position: center; background-repeat: no-repeat;">
            </div>
            <!-- char-7 uses Cal.png sprite -->
            <div id="char-7" class="character"
                style="background-image: url('assets/Cal.png'); background-size: cover; background-position: center; background-repeat: no-repeat;">
            </div>
        </div>

        <!-- Red overlay used when Cal + Baby Jeff collide -->
        <div id="screen-overlay" aria-hidden="true"></div>

    </div>

    <script>
        // --- TEXT PARSING FUNCTIONS ---

        /**
         * Splits raw text into paragraphs based on double newlines and wraps them in <p> tags.
         * @param {string} rawText The text content to process.
         * @returns {string} HTML string with text wrapped in <p> tags.
         */
        function splitParagraphs(rawText) {
            // Split text by two or more newlines to identify distinct paragraphs
            // Wrap each word in a <span class="word"> so collisions can affect individual words
            return rawText.split(/\n\s*\n/)
                .map(p => p.trim())
                .filter(p => p.length > 0) // Filter out empty strings
                .map(p => {
                    // Split on spaces but keep separators so spacing is preserved.
                    // We'll create spans for words and join with a single space.
                    const words = p.split(/\s+/).map(w => `<span class="word">${w}</span>`).join(' ');
                    return `<p>${words}</p>`;
                })
                .join('');
        }

        /**
         * Parent function for organized text processing before display.
         * @param {string} textForDisplay The final transformed text ready for the DOM.
         * @returns {string} HTML string for injection.
         */
        function ParseInput(textForDisplay) {
            return splitParagraphs(textForDisplay);
        }

        // --- APPLICATION LOGIC ---

        window.onload = function () {
            const title = document.getElementById('notebook-title');
            const documentCard = document.getElementById('document-card');
            const outputArea = document.getElementById('output-area');
            const modeSelect = document.getElementById('style-mode');
            const characterLayer = document.getElementById('character-layer');
            const characters = document.querySelectorAll('.character');
            const redactionStatus = document.getElementById('redaction-status');
            const redactionCounter = document.getElementById('redaction-counter');
            const redactionProgressBar = document.getElementById('redaction-progress-bar');

            let animationFrameId = null;
            let currentWords = [];
            // Fonts to rotate through when words are hit
            const collisionFonts = [
                'Arial, sans-serif',
                "'Comic Sans MS', 'Comic Sans', cursive",
                "'Papyrus', fantasy",
                "'Rubik Glitch', 'Arial', sans-serif"
            ];

            // --- 1. Get Input Text from URL ---
            // Default text if accessed directly without content parameter
            // const rawInputText = urlParams.get('content') || "This is default placeholder text because no content was pasted on the home page. Now try selecting a mode to see it transform! The characters will move and bump into these words to demonstrate collisions.";

            let rawInputText = localStorage.getItem('animationText') || "No text provided from index.html. Enter text in the previous step to see content here.";

            // --- 2. API Integration with FastAPI Backend ---
            const API_URL = 'http://localhost:8000/transform';
            const KEYPHRASE_API_URL = 'http://localhost:8001/extract';
            
            // Store keyphrases and redaction state
            let keyphraseIndices = [];
            let redactedCount = 0;
            let redactionEnabled = false;
            let originalTransformedText = ''; // Store the original transformed text
            let lastRedactionTime = 0; // Cooldown timer for progressive redaction
            const REDACTION_COOLDOWN = 1000; // Minimum milliseconds between redactions
            
            /**
             * Calls the FastAPI backend which uses model.py to transform text with Gemini AI
             * @param {string} text - The text to transform
             * @param {string} mode - The transformation mode
             * @returns {Promise<string>} - The transformed text
             */
            async function transformTextWithAPI(text, mode) {
                try {
                    const response = await fetch(API_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ text, mode })
                    });
                    
                    const data = await response.json();
                    return data.success ? data.transformed_text : fallbackTransform(text, mode);
                } catch (error) {
                    return fallbackTransform(text, mode);
                }
            }

            /**
             * Fetches keyphrases from the keyphrase extraction API
             * @param {string} text - The text to analyze
             * @returns {Promise<Array>} - Array of [start, end] indices
             */
            async function fetchKeyphrases(text) {
                try {
                    console.log('Fetching keyphrases from API...');
                    const response = await fetch(KEYPHRASE_API_URL, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            text: text,
                            p: 0.3  // Extract 30% of keyphrases for progressive redaction
                        })
                    });
                    
                    const data = await response.json();
                    console.log(`Received ${data.keyphrases.length} keyphrases`);
                    return data.keyphrases;
                } catch (error) {
                    console.error('Failed to fetch keyphrases:', error);
                    return [];
                }
            }

            /**
             * Finds and marks text nodes that fall within keyphrase indices
             * @param {Array} indices - Array of [start, end] pairs to redact
             */
            function applyRedactionToDOM(indices) {
                if (!indices || indices.length === 0) return;
                
                // Get all text content to build character position map
                const allText = originalTransformedText;
                let charPosition = 0;
                
                // Walk through all paragraph elements
                const paragraphs = outputArea.querySelectorAll('p');
                
                paragraphs.forEach(paragraph => {
                    const words = paragraph.querySelectorAll('.word');
                    
                    words.forEach(word => {
                        const wordText = word.textContent;
                        const wordStart = charPosition;
                        const wordEnd = charPosition + wordText.length;
                        
                        // Check if this word overlaps with any keyphrase to redact
                        let shouldRedact = false;
                        indices.forEach(([start, end]) => {
                            // Check if word range overlaps with keyphrase range
                            if (!(wordEnd <= start || wordStart >= end)) {
                                shouldRedact = true;
                            }
                        });
                        
                        if (shouldRedact && !word.classList.contains('redacted')) {
                            word.classList.add('redacted');
                            // Trigger animation
                            gsap.from(word, {
                                scaleX: 0,
                                duration: 0.4,
                                ease: 'power2.out'
                            });
                        }
                        
                        charPosition += wordText.length;
                        
                        // Account for space after word
                        if (word.nextSibling && word.nextSibling.nodeType === Node.TEXT_NODE) {
                            charPosition += word.nextSibling.textContent.length;
                        } else {
                            charPosition += 1; // space between words
                        }
                    });
                    
                    // Account for paragraph breaks
                    charPosition += 2; // \n\n between paragraphs
                });
            }

            /**
             * Progressively redacts text on collision events
             * Redacts one more keyphrase each time it's called
             */
            function progressiveRedact() {
                if (!redactionEnabled || redactedCount >= keyphraseIndices.length) {
                    return;
                }
                
                // Cooldown check: prevent rapid-fire redactions
                const now = Date.now();
                if (now - lastRedactionTime < REDACTION_COOLDOWN) {
                    return; // Too soon, skip this redaction
                }
                lastRedactionTime = now;
                
                // Redact one more keyphrase
                redactedCount++;
                // Only pass the newly added keyphrase, not all previous ones
                const newKeyphraseIndex = [keyphraseIndices[redactedCount - 1]];
                
                console.log(`Redacting ${redactedCount}/${keyphraseIndices.length} keyphrases`);
                console.log(`Redacting indices:`, keyphraseIndices[redactedCount - 1]);
                
                // Apply redaction to the DOM (only the new one)
                applyRedactionToDOM(newKeyphraseIndex);
            }

            // --- 3. Fallback Transformation Logic (if API fails) ---
            function fallbackTransform(text, mode) {
                const contentTransforms = {
                    corporate: (text) => text
                        .replace(/problem/gi, 'challenge')
                        .replace(/solution/gi, 'synergistic outcome')
                        .replace(/goal/gi, 'key deliverable')
                        .replace(/work on/gi, 'operationalize')
                        .replace(/plan/gi, 'strategic roadmap'),
                    emoji: (text) => text
                        .replace(/[.!?]/g, ' ‚ú® ')
                        .replace(/ /g, ' üíÖ ') + ' üëë',
                    argumentative: (text) => "It is logically indefensible to assume: " + text.toUpperCase() + ". Furthermore, the premise is fundamentally flawed.",
                    forgetful: (text) => text
                        .replace(/the /g, ' that one... ')
                        .replace(/is /g, ' wait, is it? ')
                        .replace(/and/g, ' or was it... and? '),
                    brainrot: (text) => text
                        .replace(/good/g, 'bussin\'')
                        .replace(/winning/g, 'slaying') + ' no cap fr.'
                };
                
                return contentTransforms[mode] ? contentTransforms[mode](text) : text;
            }

            function animateCharacter(charElement) {
                const layerBounds = characterLayer.getBoundingClientRect();
                const charWidth = charElement.clientWidth || 20;
                const charHeight = charElement.clientHeight || 20;

                const bg = (charElement.style.backgroundImage || '').toLowerCase();
                let behavior = 'normal';
                if (bg.includes('carmen')) behavior = 'carmen';
                else if (bg.includes('cal')) behavior = 'cal';
                else if (bg.includes('jeff')) behavior = 'jeff';

                function getRandomPositionFor(type) {
                    const maxX = Math.max(0, layerBounds.width - charWidth);
                    const maxY = Math.max(0, layerBounds.height - charHeight);
                    const x = gsap.utils.random(0, maxX);
                    const y = type === 'jeff' ? 
                        gsap.utils.random(maxY * 0.4, maxY * 0.85) : 
                        gsap.utils.random(0, maxY);
                    return { x, y };
                }

                function move() {
                    const newPos = getRandomPositionFor(behavior);
                    let duration = 4;
                    let ease = 'sine.inOut';

                    if (behavior === 'carmen') {
                        duration = gsap.utils.random(0.8, 2.2);
                        ease = 'power2.inOut';
                    } else if (behavior === 'jeff') {
                        duration = gsap.utils.random(6, 11);
                    } else if (behavior === 'cal') {
                        duration = gsap.utils.random(0.35, 1.1);
                        ease = 'power1.inOut';
                    } else {
                        duration = gsap.utils.random(3.5, 7.5);
                    }

                    gsap.to(charElement, {
                        x: newPos.x,
                        y: newPos.y,
                        duration,
                        ease,
                        onComplete: move
                    });

                    if (behavior === 'carmen') {
                        gsap.to(charElement, { rotation: gsap.utils.random(-18, 18), duration: Math.max(0.3, duration / 3), ease: 'sine.inOut', yoyo: true, repeat: 1 });
                    } else if (behavior === 'cal') {
                        gsap.to(charElement, { rotation: gsap.utils.random(-12, 12), duration: gsap.utils.random(0.06, 0.25), ease: 'none', yoyo: true, repeat: 1 });
                    } else if (behavior === 'jeff') {
                        gsap.to(charElement, { rotation: gsap.utils.random(-4, 4), duration: duration * 0.5, ease: 'sine.inOut' });
                    }
                }

                // Set initial random position and start the loop
                const initialPos = getRandomPositionFor(behavior);
                gsap.set(charElement, { x: initialPos.x, y: initialPos.y, rotation: 0 });
                move();
            }





            // --- 4. Collision Detection ---

            /**
             * Checks for collisions between characters and text paragraphs.
             */
            function checkCollisions() {
                if (!currentWords || currentWords.length === 0) return;

                redactionRequestedThisFrame = false;
                const cardRect = documentCard.getBoundingClientRect();

                characters.forEach(char => {
                    const charRect = char.getBoundingClientRect();

                    currentWords.forEach((w, idx) => {
                        const wRect = w.getBoundingClientRect();

                        const overlap = !(charRect.right < wRect.left ||
                            charRect.left > wRect.right ||
                            charRect.bottom < wRect.top ||
                            charRect.top > wRect.bottom);

                        if (overlap) {
                            if (w._isBouncing) return;

                            // TRIGGER PROGRESSIVE REDACTION ON COLLISION
                            progressiveRedact();

                            // We'll animate this word and a small clump around it (previous + next)
                            const neighbors = [w];
                            const clumpRadius = 1;
                            for (let r = 1; r <= clumpRadius; r++) {
                                if (currentWords[idx - r]) neighbors.push(currentWords[idx - r]);
                                if (currentWords[idx + r]) neighbors.push(currentWords[idx + r]);
                            }

                            neighbors.forEach(n => { n._isBouncing = true; n.style.transformOrigin = 'center center'; });

                            const tl = gsap.timeline({
                                onComplete: () => {
                                    neighbors.forEach(n => {
                                        n._isBouncing = false;
                                        n.style.willChange = '';
                                        if (n._prevFont !== undefined) {
                                            n.style.fontFamily = n._prevFont;
                                            delete n._prevFont;
                                        }
                                    });
                                }
                            });

                            const skewAmt = gsap.utils.random(-4, 4);

                            tl.to(neighbors, {
                                duration: 0.12,
                                y: 4,
                                scaleX: 1.02,
                                skewX: skewAmt,
                                filter: 'blur(2px)',
                                ease: 'power1.out',
                                stagger: 0.02,
                                onStart: () => {
                                    neighbors.forEach(n => {
                                        n.style.willChange = 'transform, filter';
                                        n._prevFont = n.style.fontFamily || window.getComputedStyle(n).fontFamily;
                                        const pick = collisionFonts[Math.floor(Math.random() * collisionFonts.length)];
                                        n.style.fontFamily = pick;
                                    });
                                }
                            });

                            tl.to(neighbors, {
                                duration: 0.6,
                                y: 0,
                                scaleX: 1,
                                skewX: 0,
                                filter: 'blur(0px)',
                                ease: 'elastic.out(1, 0.6)',
                                stagger: 0.02
                            });

                            gsap.fromTo(char, { scale: 1 }, { scale: 1.12, duration: 0.12, yoyo: true, repeat: 1, ease: 'power1.out' });
                        }
                    });
                });

                try {
                    const calEl = Array.from(characters).find(c => (c.style.backgroundImage || '').includes('Cal.png'));
                    const babyEl = Array.from(characters).find(c => (c.style.backgroundImage || '').toLowerCase().includes('jeffbaby'));
                    if (calEl && babyEl) {
                        const crect = calEl.getBoundingClientRect();
                        const brect = babyEl.getBoundingClientRect();
                        const overlapSpecial = !(crect.right < brect.left || crect.left > brect.right || crect.bottom < brect.top || crect.top > brect.bottom);
                        if (overlapSpecial && !window._isScreenShaking) {
                            window._isScreenShaking = true;
                            const overlay = document.getElementById('screen-overlay');
                            if (overlay) {
                                gsap.killTweensOf(overlay);
                                gsap.to(overlay, { backgroundColor: 'rgba(255,0,0,0.55)', duration: 0.08, ease: 'power1.out' });
                                gsap.to(overlay, { backgroundColor: 'rgba(255,0,0,0)', delay: 0.6, duration: 0.6, ease: 'power1.inOut' });
                            }

                            gsap.fromTo(documentCard, { x: 0 }, { x: 12, duration: 0.05, yoyo: true, repeat: 8, ease: 'power1.inOut', onComplete: () => { gsap.to(documentCard, { x: 0, duration: 0.08 }); } });
                            setTimeout(() => { window._isScreenShaking = false; }, 900);
                        }
                    }
                } catch (err) {}

                animationFrameId = requestAnimationFrame(checkCollisions);
            }


            // --- 5. Function to Handle Content Change and Animation (GSAP) ---
            async function updateContent(mode, instant = false) {
                // Stop collision checks during content transition
                if (animationFrameId) cancelAnimationFrame(animationFrameId);

                outputArea.innerHTML = '<p class="text-gray-400 italic animate-pulse">ü§ñ AI is Improving your text...</p>';

                const transformedText = await transformTextWithAPI(rawInputText, mode);
                
                // Store the original transformed text for redaction
                originalTransformedText = transformedText;

                // Fetch keyphrases from the extraction API
                keyphraseIndices = await fetchKeyphrases(transformedText);
                redactedCount = 0;
                redactionEnabled = keyphraseIndices.length > 0;
                lastRedactionTime = 0; // Reset cooldown timer for new content
                
                if (redactionEnabled) {
                    console.log(`Redaction enabled with ${keyphraseIndices.length} keyphrases`);
                } else {
                    console.log('No keyphrases found - redaction disabled');
                }

                const newContentHTML = ParseInput(transformedText);

                if (instant) {
                    outputArea.innerHTML = newContentHTML;
                    currentWords = outputArea.querySelectorAll('.word');
                    gsap.set(currentWords, { opacity: 1, y: 0, scaleX: 1, skewX: 0, filter: 'none' });
                    animationFrameId = requestAnimationFrame(checkCollisions);
                    return;
                }

                gsap.to(outputArea.children, {
                    opacity: 0,
                    y: 10,
                    duration: 0.18,
                    stagger: 0.02,
                    ease: "power1.in",
                    onComplete: () => {
                        outputArea.innerHTML = newContentHTML;
                        currentWords = outputArea.querySelectorAll('.word');

                        gsap.from(currentWords, {
                            opacity: 0,
                            y: -6,
                            duration: 0.18,
                            stagger: 0.005,
                            ease: "power2.out",
                            onComplete: () => {
                                animationFrameId = requestAnimationFrame(checkCollisions);
                            }
                        });
                    }
                });
            }

            function initialize() {
                updateContent(modeSelect.value, true);
                gsap.from(title, { opacity: 0, y: -20, duration: 1, ease: "power2.out" });
                characters.forEach(animateCharacter);
            }

            modeSelect.addEventListener('change', (e) => updateContent(e.target.value));

            initialize();
        };
    </script>

</body>

</html>