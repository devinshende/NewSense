<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Content Editor</title>
    <!-- Load Tailwind CSS for styling and responsiveness -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load GSAP Core Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
            overflow-x: hidden;
            /* Prevent horizontal scroll from character movement */
        }

        .mode-select {
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20'%3E%3Cpath fill='%236B7280' d='M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 0.75rem center;
            background-size: 1.5em;
        }

        /* Style for the document container */
        .document-card {
            background-color: #ffffff;
            border-radius: 1rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            max-width: 4xl;
            width: 90%;
            /* Relative position needed for absolute children (character layer) */
            position: relative;
        }

        /* Layer for the animated characters, positioned over the content */
        #character-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            /* Allows clicks to pass through to the document below */
            z-index: 10;
        }



        .character {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            position: absolute;
            opacity: 0.9;
            pointer-events: none;
            box-shadow: 0 6px 14px rgba(16, 24, 40, 0.12);
        }

        /* Make the moneyjeff sprite larger without affecting other characters */
        #char-5 {
            width: 72px;
            height: 72px;
        }

        /* Make the UCSC jeff sprite twice the base character size */
        #char-3 {
            width: 96px;
            height: 140px;
        }
    </style>
</head>

<body class="flex flex-col items-center min-h-screen p-6 md:p-10">

    <!-- Document Container -->
    <div id="document-card" class="document-card p-8 md:p-16 w-full">

        <a href="index.html" class="inline-flex items-center text-blue-600 hover:text-blue-800 mb-6 font-medium">
            <!-- Back Arrow SVG Icon -->
            <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"
                xmlns="http://www.w3.org/2000/svg">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18">
                </path>
            </svg>
            Back to Input
        </a>

        <!-- Title Section -->
        <h1 id="notebook-title"
            class="text-4xl md:text-5xl font-black mb-4 text-gray-800 border-b-2 pb-4 border-gray-200">
            Focus Mode
        </h1>

        <!-- Mode Selector Dropdown -->
        <div class="mb-10 flex flex-col sm:flex-row sm:items-center space-y-3 sm:space-y-0 sm:space-x-4">
            <label for="style-mode" class="text-lg font-semibold text-gray-700">Select Mode:</label>
            <select id="style-mode"
                class="mode-select block w-full sm:w-64 p-3 border border-gray-300 rounded-lg bg-gray-50 focus:ring-blue-500 focus:border-blue-500 text-base mode-select cursor-pointer">
                <option value="corporate">üíº LinkedIn / Corporate Speak</option>
                <option value="emoji">üòÇ Horrible Emojis Copypasta</option>
                <option value="argumentative">‚öîÔ∏è Argumentative Mode</option>
                <option value="forgetful">ü§î Forgetful Mode</option>
                <option value="brainrot">ü§™ Brainrot / Slang</option>
            </select>
        </div>

        <!-- Output Area for Generated Text -->
        <div id="output-area" class="space-y-6 text-lg text-gray-700 leading-relaxed min-h-[400px]">
            <!-- Content will be injected here by JavaScript -->
            <p>Paste text on the home page to begin transformation.</p>
        </div>

        <!-- Character Animation Layer -->
        <div id="character-layer">
            <div id="char-1" class="character" style="background-color: #a21f1f;"></div>
            <div id="char-2" class="character" style="background-color: #60a5fa;"></div>
            <!-- char-3 uses an image sprite from assets/ucscjeff.png -->
            <div id="char-3" class="character"
                style="background-image: url('assets/ucscjeff.png'); background-size: cover; background-position: center; background-repeat: no-repeat;">
            </div>
            <div id="char-4" class="character" style="background-color: #46a60f;"></div>
            <!-- char-5 uses an image sprite from assets/moneyjeff.png -->
            <div id="char-5" class="character"
                style="background-image: url('assets/moneyjeff.png'); background-size: cover; background-position: center; background-repeat: no-repeat;">
            </div>
            <div id="char-6" class="character" style="background-color: #b393d9;"></div>
            <div id="char-7" class="character" style="background-color: #34d399;"></div>
        </div>

    </div>

    <script>
        // --- TEXT PARSING FUNCTIONS ---

        /**
         * Splits raw text into paragraphs based on double newlines and wraps them in <p> tags.
         * @param {string} rawText The text content to process.
         * @returns {string} HTML string with text wrapped in <p> tags.
         */
        function splitParagraphs(rawText) {
            // Split text by two or more newlines to identify distinct paragraphs
            return rawText.split(/\n\s*\n/)
                .map(p => p.trim())
                .filter(p => p.length > 0) // Filter out empty strings
                .map(p => `<p>${p}</p>`)
                .join('');
        }

        /**
         * Parent function for organized text processing before display.
         * @param {string} textForDisplay The final transformed text ready for the DOM.
         * @returns {string} HTML string for injection.
         */
        function ParseInput(textForDisplay) {
            return splitParagraphs(textForDisplay);
        }

        // --- APPLICATION LOGIC ---

        window.onload = function () {
            const title = document.getElementById('notebook-title');
            const documentCard = document.getElementById('document-card');
            const outputArea = document.getElementById('output-area');
            const modeSelect = document.getElementById('style-mode');
            const characterLayer = document.getElementById('character-layer');
            const characters = document.querySelectorAll('.character');

            let animationFrameId = null;
            let currentParagraphs = [];

            // --- 1. Get Input Text from URL ---
            // Default text if accessed directly without content parameter
            // const rawInputText = urlParams.get('content') || "This is default placeholder text because no content was pasted on the home page. Now try selecting a mode to see it transform! The characters will move and bump into these words to demonstrate collisions.";

            let rawInputText = localStorage.getItem('animationText') || "No text provided from index.html. Enter text in the previous step to see content here.";

            // --- 2. Transformation Logic (Placeholder Function) ---
            const contentTransforms = {
                corporate: (text) => text
                    .replace(/problem/gi, 'challenge')
                    .replace(/solution/gi, 'synergistic outcome')
                    .replace(/goal/gi, 'key deliverable')
                    .replace(/work on/gi, 'operationalize')
                    .replace(/plan/gi, 'strategic roadmap'),
                emoji: (text) => text
                    .replace(/[.!?]/g, ' ‚ú® ')
                    .replace(/ /g, ' üíÖ ') + ' üëë',
                argumentative: (text) => "It is logically indefensible to assume: " + text.toUpperCase() + ". Furthermore, the premise is fundamentally flawed.",
                forgetful: (text) => text
                    .replace(/the /g, ' that one... ')
                    .replace(/is /g, ' wait, is it? ')
                    .replace(/and/g, ' or was it... and? '),
                brainrot: (text) => text
                    .replace(/good/g, 'bussin\'')
                    .replace(/winning/g, 'slaying') + ' no cap fr.'
            };

            // --- 3. GSAP Character Movement ---

            /**
             * Starts a continuous, random movement loop for a single character.
             * @param {HTMLElement} charElement The character DOM element.
             */
            function animateCharacter(charElement) {
                const layerBounds = characterLayer.getBoundingClientRect();

                // Compute character size from the DOM so positioning matches visual size and transforms
                const charWidth = charElement.clientWidth || 20;
                const charHeight = charElement.clientHeight || 20;

                // Function to generate a new random position within the layer
                function getRandomPosition() {
                    return {
                        x: gsap.utils.random(0, Math.max(0, layerBounds.width - charWidth)),
                        y: gsap.utils.random(0, Math.max(0, layerBounds.height - charHeight))
                    };
                }

                function move() {
                    const newPos = getRandomPosition();

                    gsap.to(charElement, {
                        x: newPos.x,
                        y: newPos.y,
                        duration: gsap.utils.random(4, 8), // Random speed
                        ease: "sine.inOut",
                        onComplete: move // Loop the movement indefinitely
                    });
                }

                // Set initial random position and start the loop
                const initialPos = getRandomPosition();
                gsap.set(charElement, { x: initialPos.x, y: initialPos.y });
                move();
            }





            // --- 4. Collision Detection ---

            /**
             * Checks for collisions between characters and text paragraphs.
             */
            function checkCollisions() {
                if (currentParagraphs.length === 0) return;

                // Update card rect once per frame
                const cardRect = documentCard.getBoundingClientRect();

                characters.forEach(char => {
                    // Use boundingClientRect to account for GSAP transform (x/y)
                    const charRect = char.getBoundingClientRect();

                    currentParagraphs.forEach(p => {
                        const pRect = p.getBoundingClientRect();

                        // Simple AABB overlap check in viewport coordinates
                        const overlap = !(charRect.right < pRect.left ||
                            charRect.left > pRect.right ||
                            charRect.bottom < pRect.top ||
                            charRect.top > pRect.bottom);

                        if (overlap) {
                            // Prevent repeated triggering on the same paragraph until animation finishes
                            if (p._isBouncing) return;
                            p._isBouncing = true;

                            // Ensure transform origin so the warp looks natural
                            p.style.transformOrigin = 'center center';

                            // Warp + elastic bounce timeline
                            const tl = gsap.timeline({
                                onComplete: () => { p._isBouncing = false; }
                            });

                            // Quick warp/skew + nudge in the direction of the collision
                            const skewAmt = gsap.utils.random(-8, 8);
                            tl.to(p, {
                                duration: 0.12,
                                y: 8,
                                scaleX: 1.03,
                                skewX: skewAmt,
                                ease: 'power1.out'
                            });

                            // Elastic return for a bouncy feeling
                            tl.to(p, {
                                duration: 0.8,
                                y: 0,
                                scaleX: 1,
                                skewX: 0,
                                ease: 'elastic.out(1, 0.6)'
                            });

                            // Small character reaction (scale only - do not change background color)
                            gsap.fromTo(char, { scale: 1 }, {
                                scale: 1.18,
                                duration: 0.12,
                                yoyo: true,
                                repeat: 1,
                                ease: 'power1.out'
                            });
                        }
                    });
                });

                animationFrameId = requestAnimationFrame(checkCollisions);
            }


            // --- 5. Function to Handle Content Change and Animation (GSAP) ---
            function updateContent(mode) {
                // Stop collision checks during content transition
                if (animationFrameId) cancelAnimationFrame(animationFrameId);

                // Apply the selected transformation
                const transformedText = contentTransforms[mode]
                    ? contentTransforms[mode](rawInputText)
                    : rawInputText;

                // Use the new ParseInput function to prepare the HTML
                const newContentHTML = ParseInput(transformedText);

                // 1. Animate OUT the current content (Fade and slide down)
                gsap.to(outputArea.children, {
                    opacity: 0,
                    y: 10,
                    duration: 0.3,
                    stagger: 0.05,
                    ease: "power1.in",
                    onComplete: () => {
                        // 2. Clear old content and inject new HTML
                        outputArea.innerHTML = newContentHTML;

                        // Update the reference to the new paragraphs
                        currentParagraphs = outputArea.querySelectorAll('p');

                        // 3. Animate IN the new content (Fade and slide up)
                        gsap.from(currentParagraphs, {
                            opacity: 0,
                            y: -10, // Slide up from slightly above
                            duration: 0.5,
                            stagger: 0.08,
                            ease: "power2.out",
                            onComplete: () => {
                                // 4. Restart collision detection after content is stable
                                animationFrameId = requestAnimationFrame(checkCollisions);
                            }
                        });
                    }
                });
            }

            // --- 6. Initialization ---
            function initialize() {
                // Initial Content Load (using the first mode for display)
                updateContent(modeSelect.value);

                // Initial Page Animation (Title fade-in)
                gsap.from(title, { opacity: 0, y: -20, duration: 1, ease: "power2.out" });

                // Start character animations
                characters.forEach(animateCharacter);
            }

            // --- 7. Event Listener ---
            modeSelect.addEventListener('change', (event) => {
                const selectedMode = event.target.value;
                updateContent(selectedMode);
            });

            initialize();
        };
    </script>

</body>

</html>