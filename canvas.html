<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Content Editor</title>
    <!-- Load Tailwind CSS for styling and responsiveness -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load GSAP Core Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
            overflow-x: hidden;
            /* Prevent horizontal scroll from character movement */
        }

        .mode-select {
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20'%3E%3Cpath fill='%236B7280' d='M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 0.75rem center;
            background-size: 1.5em;
        }

        /* Style for the document container */
        .document-card {
            background-color: #ffffff;
            border-radius: 1rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            max-width: 4xl;
            width: 90%;
            /* Relative position needed for absolute children (character layer) */
            position: relative;
        }

        /* Layer for the animated characters, positioned over the content */
        #character-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            /* Allows clicks to pass through to the document below */
            z-index: 10;
        }



        .character {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            position: absolute;
            opacity: 0.9;
            pointer-events: none;
            box-shadow: 0 6px 14px rgba(16, 24, 40, 0.12);
        }

        /* Words are inline-block so we can transform/blur individual words without collapsing layout */
        .word {
            display: inline-block;
            white-space: pre;
            /* preserve spaces/newlines between words */
            will-change: transform, filter;
        }

        /* Kristina sprite sizing */
        #char-5 {
            width: 100px;
            height: 140px;
        }

        /* Make the UCSC jeff sprite twice the base character size */
        #char-3 {
            width: 96px;
            height: 96px;
        }

        /* baby girl Jeff */
        #char-6 {
            width: 140px;
            height: 140px;
        }

        /* Make the Cal sprite larger */
        #char-7 {
            width: 146px;
            height: 146px;
        }

        /* Carmen sprite sizing */
        #char-4 {
            width: 100px;
            height: 160px;
        }

        /* Sabina sprite sizing */
        #char-2 {
            width: 50px;
            height: 150px;
        }

        /* Full-area red overlay for special collision effect (initially transparent) */
        #screen-overlay {
            position: absolute;
            inset: 0;
            background-color: rgba(255, 0, 0, 0);
            pointer-events: none;
            z-index: 40;
            border-radius: 1rem;
        }
    </style>
</head>

<body class="flex flex-col items-center min-h-screen p-6 md:p-10">

    <!-- Document Container -->
    <div id="document-card" class="document-card p-8 md:p-16 w-full">

        <a href="index.html" class="inline-flex items-center text-blue-600 hover:text-blue-800 mb-6 font-medium">
            <!-- Back Arrow SVG Icon -->
            <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"
                xmlns="http://www.w3.org/2000/svg">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18">
                </path>
            </svg>
            Back to Input
        </a>

        <!-- Title Section -->
        <h1 id="notebook-title"
            class="text-4xl md:text-5xl font-black mb-4 text-gray-800 border-b-2 pb-4 border-gray-200">
            Focus Mode
        </h1>

        <!-- Mode Selector Dropdown -->
        <div class="mb-10 flex flex-col sm:flex-row sm:items-center space-y-3 sm:space-y-0 sm:space-x-4">
            <label for="style-mode" class="text-lg font-semibold text-gray-700">Select Mode:</label>
            <select id="style-mode"
                class="mode-select block w-full sm:w-64 p-3 border border-gray-300 rounded-lg bg-gray-50 focus:ring-blue-500 focus:border-blue-500 text-base mode-select cursor-pointer">
                <option value="corporate">üíº LinkedIn / Corporate Speak</option>
                <option value="emoji">üòÇ Horrible Emojis Copypasta</option>
                <option value="argumentative">‚öîÔ∏è Argumentative Mode</option>
                <option value="forgetful">ü§î Forgetful Mode</option>
                <option value="brainrot">ü§™ Brainrot / Slang</option>
            </select>
        </div>

        <!-- Output Area for Generated Text -->
        <div id="output-area" class="space-y-6 text-lg text-gray-700 leading-relaxed min-h-[400px]">
            <!-- Content will be injected here by JavaScript -->
            <p>Paste text on the home page to begin transformation.</p>
        </div>

        <!-- Character Animation Layer -->
        <div id="character-layer">
            <div id="char-1" class="character" style="background-color: #a21f1f;"></div>
            <!-- char-2 uses Sabina.png sprite -->
            <div id="char-2" class="character"
                style="background-image: url('assets/Sabina.png'); background-size: cover; background-position: center; background-repeat: no-repeat;">
            </div>
            <!-- char-3 uses an image sprite from assets/ucscjeff.png -->
            <div id="char-3" class="character"
                style="background-image: url('assets/ucscjeff.png'); background-size: cover; background-position: center; background-repeat: no-repeat;">
            </div>
            <!-- char-4 uses Carmen.png sprite -->
            <div id="char-4" class="character"
                style="background-image: url('assets/Carmen.png'); background-size: cover; background-position: center; background-repeat: no-repeat;">
            </div>
            <!-- char-5 uses an image sprite from assets/Kristina.png -->
            <div id="char-5" class="character"
                style="background-image: url('assets/Kristina.png'); background-size: cover; background-position: center; background-repeat: no-repeat;">
            </div>
            <div id="char-6" class="character" style="background-color: #b393d9;"></div>
            <!-- char-6 uses jeffbaby placeholder SVG (replace with PNG if you add it into assets/) -->
            <div id="char-6" class="character"
                style="background-image: url('assets/jeffbaby.JPG'); background-size: cover; background-position: center; background-repeat: no-repeat;">
            </div>
            <!-- char-7 uses Cal.png sprite -->
            <div id="char-7" class="character"
                style="background-image: url('assets/Cal.png'); background-size: cover; background-position: center; background-repeat: no-repeat;">
            </div>
        </div>

        <!-- Red overlay used when Cal + Baby Jeff collide -->
        <div id="screen-overlay" aria-hidden="true"></div>

    </div>

    <script>
        // --- TEXT PARSING FUNCTIONS ---

        /**
         * Splits raw text into paragraphs based on double newlines and wraps them in <p> tags.
         * @param {string} rawText The text content to process.
         * @returns {string} HTML string with text wrapped in <p> tags.
         */
        function splitParagraphs(rawText) {
            // Split text by two or more newlines to identify distinct paragraphs
            // Wrap each word in a <span class="word"> so collisions can affect individual words
            return rawText.split(/\n\s*\n/)
                .map(p => p.trim())
                .filter(p => p.length > 0) // Filter out empty strings
                .map(p => {
                    // Split on spaces but keep separators so spacing is preserved.
                    // We'll create spans for words and join with a single space.
                    const words = p.split(/\s+/).map(w => `<span class="word">${w}</span>`).join(' ');
                    return `<p>${words}</p>`;
                })
                .join('');
        }

        /**
         * Parent function for organized text processing before display.
         * @param {string} textForDisplay The final transformed text ready for the DOM.
         * @returns {string} HTML string for injection.
         */
        function ParseInput(textForDisplay) {
            return splitParagraphs(textForDisplay);
        }

        // --- APPLICATION LOGIC ---

        window.onload = function () {
            const title = document.getElementById('notebook-title');
            const documentCard = document.getElementById('document-card');
            const outputArea = document.getElementById('output-area');
            const modeSelect = document.getElementById('style-mode');
            const characterLayer = document.getElementById('character-layer');
            const characters = document.querySelectorAll('.character');

            let animationFrameId = null;
            let currentWords = [];
            // Fonts to rotate through when words are hit
            const collisionFonts = [
                'Arial, sans-serif',
                "'Comic Sans MS', 'Comic Sans', cursive",
                "'Papyrus', fantasy",
                "'Rubik Glitch', 'Arial', sans-serif"
            ];

            // --- 1. Get Input Text from URL ---
            // Default text if accessed directly without content parameter
            // const rawInputText = urlParams.get('content') || "This is default placeholder text because no content was pasted on the home page. Now try selecting a mode to see it transform! The characters will move and bump into these words to demonstrate collisions.";

            let rawInputText = localStorage.getItem('animationText') || "No text provided from index.html. Enter text in the previous step to see content here.";

            // --- 2. API Integration with FastAPI Backend ---
            const API_URL = 'http://localhost:8000/transform';
            
            /**
             * Calls the FastAPI backend which uses model.py to transform text with Gemini AI
             * @param {string} text - The text to transform
             * @param {string} mode - The transformation mode
             * @returns {Promise<string>} - The transformed text
             */
            async function transformTextWithAPI(text, mode) {
                try {
                    console.log(`Calling API with mode: ${mode}`);
                    const response = await fetch(API_URL, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            text: text,
                            mode: mode
                        })
                    });
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        console.log('API transformation successful');
                        return data.transformed_text;
                    } else {
                        console.error('API Error:', data.error);
                        // Fallback to basic transformation
                        return fallbackTransform(text, mode);
                    }
                } catch (error) {
                    console.error('Network Error - API server may not be running:', error);
                    console.log('Using fallback transformation');
                    // Fallback to basic transformations if API is unavailable
                    return fallbackTransform(text, mode);
                }
            }

            // --- 3. Fallback Transformation Logic (if API fails) ---
            function fallbackTransform(text, mode) {
                const contentTransforms = {
                    corporate: (text) => text
                        .replace(/problem/gi, 'challenge')
                        .replace(/solution/gi, 'synergistic outcome')
                        .replace(/goal/gi, 'key deliverable')
                        .replace(/work on/gi, 'operationalize')
                        .replace(/plan/gi, 'strategic roadmap'),
                    emoji: (text) => text
                        .replace(/[.!?]/g, ' ‚ú® ')
                        .replace(/ /g, ' üíÖ ') + ' üëë',
                    argumentative: (text) => "It is logically indefensible to assume: " + text.toUpperCase() + ". Furthermore, the premise is fundamentally flawed.",
                    forgetful: (text) => text
                        .replace(/the /g, ' that one... ')
                        .replace(/is /g, ' wait, is it? ')
                        .replace(/and/g, ' or was it... and? '),
                    brainrot: (text) => text
                        .replace(/good/g, 'bussin\'')
                        .replace(/winning/g, 'slaying') + ' no cap fr.'
                };
                
                return contentTransforms[mode] ? contentTransforms[mode](text) : text;
            }

            // --- 4. GSAP Character Movement ---

            /**
             * Starts a continuous, random movement loop for a single character.
             * Behavior changes based on sprite: Carmen (fast, flying), Jeff (slower), Cal (erratic).
             * @param {HTMLElement} charElement The character DOM element.
             */
            function animateCharacter(charElement) {
                const layerBounds = characterLayer.getBoundingClientRect();

                // Compute character size from the DOM so positioning matches visual size and transforms
                const charWidth = charElement.clientWidth || 20;
                const charHeight = charElement.clientHeight || 20;

                const bg = (charElement.style.backgroundImage || '').toLowerCase();
                let behavior = 'normal';
                if (bg.includes('carmen')) behavior = 'carmen';
                else if (bg.includes('cal')) behavior = 'cal';
                else if (bg.includes('jeff')) behavior = 'jeff';

                function getRandomPositionFor(type) {
                    const maxX = Math.max(0, layerBounds.width - charWidth);
                    const maxY = Math.max(0, layerBounds.height - charHeight);
                    const x = gsap.utils.random(0, maxX);
                    let y;
                    if (type === 'jeff') {
                        // keep Jeff nearer to the middle/lower area for a grounded feel
                        y = gsap.utils.random(maxY * 0.4, maxY * 0.85);
                    } else {
                        // Carmen/Cal/normal roam the full area
                        y = gsap.utils.random(0, maxY);
                    }
                    return { x, y };
                }

                function move() {
                    const newPos = getRandomPositionFor(behavior);
                    let duration = 4;
                    let ease = 'sine.inOut';

                    if (behavior === 'carmen') {
                        // fast, frequent moves; simulate flying with quicker durations
                        duration = gsap.utils.random(0.8, 2.2);
                        ease = 'power2.inOut';
                    } else if (behavior === 'jeff') {
                        // slower, more languid movement
                        duration = gsap.utils.random(6, 11);
                        ease = 'sine.inOut';
                    } else if (behavior === 'cal') {
                        // erratic: short moves and quick direction changes
                        duration = gsap.utils.random(0.35, 1.1);
                        ease = 'power1.inOut';
                    } else {
                        duration = gsap.utils.random(3.5, 7.5);
                    }

                    gsap.to(charElement, {
                        x: newPos.x,
                        y: newPos.y,
                        duration,
                        ease,
                        onComplete: move
                    });

                    // Add small behavioral flourishes
                    if (behavior === 'carmen') {
                        // flap/tilt while moving
                        gsap.to(charElement, { rotation: gsap.utils.random(-18, 18), duration: Math.max(0.3, duration / 3), ease: 'sine.inOut', yoyo: true, repeat: 1 });
                    } else if (behavior === 'cal') {
                        // jitter rotation to emphasize erratic direction changes
                        gsap.to(charElement, { rotation: gsap.utils.random(-12, 12), duration: gsap.utils.random(0.06, 0.25), ease: 'none', yoyo: true, repeat: 1 });
                    } else if (behavior === 'jeff') {
                        // subtle slow bob
                        gsap.to(charElement, { rotation: gsap.utils.random(-4, 4), duration: duration * 0.5, ease: 'sine.inOut' });
                    }
                }

                // Set initial random position and start the loop
                const initialPos = getRandomPositionFor(behavior);
                gsap.set(charElement, { x: initialPos.x, y: initialPos.y, rotation: 0 });
                move();
            }





            // --- 4. Collision Detection ---

            /**
             * Checks for collisions between characters and text paragraphs.
             */
            function checkCollisions() {
                if (!currentWords || currentWords.length === 0) return;

                // Update card rect once per frame
                const cardRect = documentCard.getBoundingClientRect();

                characters.forEach(char => {
                    // Use boundingClientRect to account for GSAP transform (x/y)
                    const charRect = char.getBoundingClientRect();

                    // Check each word for collision
                    currentWords.forEach((w, idx) => {
                        const wRect = w.getBoundingClientRect();

                        const overlap = !(charRect.right < wRect.left ||
                            charRect.left > wRect.right ||
                            charRect.bottom < wRect.top ||
                            charRect.top > wRect.bottom);

                        if (overlap) {
                            // If this word is already animating, skip
                            if (w._isBouncing) return;

                            // We'll animate this word and a small clump around it (previous + next)
                            const neighbors = [w];
                            const clumpRadius = 1; // number of neighbor words on each side
                            for (let r = 1; r <= clumpRadius; r++) {
                                if (currentWords[idx - r]) neighbors.push(currentWords[idx - r]);
                                if (currentWords[idx + r]) neighbors.push(currentWords[idx + r]);
                            }

                            neighbors.forEach(n => { n._isBouncing = true; n.style.transformOrigin = 'center center'; });

                            const tl = gsap.timeline({
                                onComplete: () => {
                                    neighbors.forEach(n => {
                                        n._isBouncing = false;
                                        n.style.willChange = '';
                                        if (n._prevFont !== undefined) {
                                            n.style.fontFamily = n._prevFont;
                                            delete n._prevFont;
                                        }
                                    });
                                }
                            });

                            const skewAmt = gsap.utils.random(-4, 4);

                            // Apply small nudge + blur to each neighbor (staggered slightly)
                            tl.to(neighbors, {
                                duration: 0.12,
                                y: 4,
                                scaleX: 1.02,
                                skewX: skewAmt,
                                filter: 'blur(2px)',
                                ease: 'power1.out',
                                stagger: 0.02,
                                onStart: () => {
                                    neighbors.forEach(n => {
                                        n.style.willChange = 'transform, filter';
                                        // store previous font and apply a random hit font from the list
                                        try {
                                            n._prevFont = n.style.fontFamily || window.getComputedStyle(n).fontFamily;
                                        } catch (err) {
                                            n._prevFont = '';
                                        }
                                        try {
                                            const pick = collisionFonts[Math.floor(Math.random() * collisionFonts.length)];
                                            n._hitFont = pick;
                                            n.style.fontFamily = pick;
                                        } catch (e) {
                                            // fallback to Comic Sans if anything goes wrong
                                            n.style.fontFamily = "'Comic Sans MS', 'Comic Sans', cursive";
                                        }
                                    });
                                }
                            });

                            // Return to normal
                            tl.to(neighbors, {
                                duration: 0.6,
                                y: 0,
                                scaleX: 1,
                                skewX: 0,
                                filter: 'blur(0px)',
                                ease: 'elastic.out(1, 0.6)',
                                stagger: 0.02
                            });

                            // Subtle character reaction
                            gsap.fromTo(char, { scale: 1 }, { scale: 1.12, duration: 0.12, yoyo: true, repeat: 1, ease: 'power1.out' });
                        }
                    });
                });

                // --- Special-case collision: if Cal and Baby Jeff overlap, trigger screen shake + red overlay ---
                try {
                    const calEl = Array.from(characters).find(c => (c.style.backgroundImage || '').includes('Cal.png'));
                    const babyEl = Array.from(characters).find(c => (c.style.backgroundImage || '').toLowerCase().includes('jeffbaby'));
                    if (calEl && babyEl) {
                        const crect = calEl.getBoundingClientRect();
                        const brect = babyEl.getBoundingClientRect();
                        const overlapSpecial = !(crect.right < brect.left || crect.left > brect.right || crect.bottom < brect.top || crect.top > brect.bottom);
                        if (overlapSpecial && !window._isScreenShaking) {
                            window._isScreenShaking = true;
                            const overlay = document.getElementById('screen-overlay');
                            if (overlay) {
                                gsap.killTweensOf(overlay);
                                gsap.to(overlay, { backgroundColor: 'rgba(255,0,0,0.55)', duration: 0.08, ease: 'power1.out' });
                                gsap.to(overlay, { backgroundColor: 'rgba(255,0,0,0)', delay: 0.6, duration: 0.6, ease: 'power1.inOut' });
                            }

                            // Quick shake the document card
                            gsap.fromTo(documentCard, { x: 0 }, { x: 12, duration: 0.05, yoyo: true, repeat: 8, ease: 'power1.inOut', onComplete: () => { gsap.to(documentCard, { x: 0, duration: 0.08 }); } });

                            // reset flag after the visual effect completes
                            setTimeout(() => { window._isScreenShaking = false; }, 900);
                        }
                    }
                } catch (err) {
                    // ignore any DOM exceptions during collision checks
                    console.warn('Special collision check error', err);
                }

                animationFrameId = requestAnimationFrame(checkCollisions);
            }


            // --- 5. Function to Handle Content Change and Animation (GSAP) ---
            function updateContent(mode, instant = false) {
                // Stop collision checks during content transition
                if (animationFrameId) cancelAnimationFrame(animationFrameId);

                // Show loading state
                outputArea.innerHTML = '<p class="text-gray-400 italic animate-pulse">ü§ñ AI is Improving your text...</p>';

                // Call the API to transform text using model.py
                const transformedText = await transformTextWithAPI(rawInputText, mode);

                // Use the new ParseInput function to prepare the HTML
                const newContentHTML = ParseInput(transformedText);

                if (instant) {
                    // Immediately replace content without animating (useful for initial load)
                    outputArea.innerHTML = newContentHTML;
                    currentWords = outputArea.querySelectorAll('.word');
                    // Ensure words are visible and reset transforms
                    gsap.set(currentWords, { opacity: 1, y: 0, scaleX: 1, skewX: 0, filter: 'none' });
                    animationFrameId = requestAnimationFrame(checkCollisions);
                    return;
                }

                // 1. Animate OUT the current content (Fade and slide down)
                gsap.to(outputArea.children, {
                    opacity: 0,
                    y: 10,
                    duration: 0.18,
                    stagger: 0.02,
                    ease: "power1.in",
                    onComplete: () => {
                        // 2. Clear old content and inject new HTML
                        outputArea.innerHTML = newContentHTML;

                        // Update the reference to the new word elements
                        currentWords = outputArea.querySelectorAll('.word');

                        // 3. Animate IN the new content (Fade and slide up per word)
                        gsap.from(currentWords, {
                            opacity: 0,
                            y: -6, // Slide up from slightly above
                            duration: 0.18,
                            stagger: 0.005,
                            ease: "power2.out",
                            onComplete: () => {
                                // 4. Restart collision detection after content is stable
                                animationFrameId = requestAnimationFrame(checkCollisions);
                            }
                        });
                    }
                });
            }

            // --- 6. Initialization ---
            function initialize() {
                // Initial Content Load (using the first mode for display) - inject instantly
                updateContent(modeSelect.value, true);

                // Initial Page Animation (Title fade-in)
                gsap.from(title, { opacity: 0, y: -20, duration: 1, ease: "power2.out" });

                // Start character animations
                characters.forEach(animateCharacter);
            }

            // --- 7. Event Listener ---
            modeSelect.addEventListener('change', (event) => {
                const selectedMode = event.target.value;
                updateContent(selectedMode);
            });

            initialize();
        };
    </script>

</body>

</html>